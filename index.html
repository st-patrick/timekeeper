<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- iOS PWA status bar (standalone). We'll override via JS on load too. -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">


<link rel="manifest" href="/manifest.json">
<title>timekeeper</title>
<style>
  :root{--bg:#0b0b0f;--card:#14141b;--fg:#e9e9ef;--muted:#9aa0aa;--border:#1f2230;--shadow:0 8px 24px rgba(0,0,0,.35);--radius:12px}
  @media (prefers-color-scheme: light){:root{--bg:#f7f8fb;--card:#fff;--fg:#222;--muted:#6b7280;--border:#e6e8ef;--shadow:0 8px 20px rgba(30,45,75,.09)}}
  html,body{height:100%}
  body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--fg);
       display:grid;place-items:start center;padding:10px}
  .wrap{width:100%;max-width:820px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);padding:12px}
  .head{display:flex;align-items:center;justify-content:space-between;gap:6px;margin-bottom:6px}
  .title{display:flex;align-items:center;gap:8px}
  .title .emoji{font-size:20px;filter:drop-shadow(0 1px 0 rgba(0,0,0,.25))}
  h1{font-size:22px;margin:0}
  .icon-btn{width:30px;height:30px;display:grid;place-items:center;border-radius:9px;border:1px solid var(--border);
           background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(0,0,0,.04));color:var(--fg);cursor:pointer}
  .icon-btn:active{transform:translateY(1px)}
  .muted{color:var(--muted);font-size:13px}

  .badge{display:flex;align-items:center;gap:8px;padding:8px 10px;border:1px solid var(--border);border-radius:10px;
         background:linear-gradient(135deg,rgba(122,162,255,.16),rgba(201,162,255,.16));margin:6px 0 8px}
  .badge .spacer{flex:1}

  textarea{width:100%;min-height:96px;resize:vertical;background:#0f1117;color:var(--fg);border:1px solid var(--border);
           border-radius:10px;padding:10px 12px;line-height:1.35;font-size:15px;outline:none; box-sizing:border-box;}
  @media (prefers-color-scheme: light){textarea{background:#fbfbfe}}
  textarea::placeholder{color:#8b90a1}
  textarea:focus{border-color:rgba(122,162,255,.7);box-shadow:0 0 0 3px rgba(122,162,255,.14)}
  .row{display:flex;align-items:center;gap:8px;margin-top:6px}
  button{appearance:none;cursor:pointer;border:1px solid var(--border);
         background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(0,0,0,.04));color:var(--fg);
         border-radius:10px;font-weight:600;letter-spacing:.15px}
  #enable{background:linear-gradient(135deg,rgba(122,162,255,.28),rgba(201,162,255,.28));border-color:rgba(122,162,255,.5)}
  .hint{font-size:12px}

  /* Settings panel */
  #settings{display:none;border:1px solid var(--border);border-radius:10px;padding:10px;margin:6px 0 8px;background:rgba(255,255,255,.03)}
  .settings-grid{display:grid;grid-template-columns:1fr 160px;gap:8px}
  .settings-grid input{width:100%;border:1px solid var(--border);border-radius:8px;padding:8px 10px;background:#0f1117;color:var(--fg)}
  @media (prefers-color-scheme: light){.settings-grid input{background:#fbfbfe}}
  .settings-actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}

  /* Grouping compact */
  .toolbar{display:flex;align-items:center;justify-content:space-between;margin:8px 0}
  .groups{display:grid;gap:6px}
  .year-title{font-weight:800;opacity:.9;margin:2px 0}
  .month-title{font-weight:700;opacity:.85;margin:2px 0}
  details.day{padding:6px 0px}
  details.day>summary{list-style:none;cursor:pointer;display:flex;align-items:center;justify-content:space-between;gap:8px}
  details.day>summary::-webkit-details-marker{display:none}
  .day-count{font-size:12px;color:var(--muted)}
  .entries{list-style:none;padding:0;margin:6px 0 0}
  details.entry{padding:6px 0px;margin:4px 0;}
  details.entry>summary{list-style:none;cursor:pointer;display:flex}
  details.entry>summary::-webkit-details-marker{display:none}
  .entry-text{color:var(--fg);font-size:14px}
  .entry-meta{display:flex;align-items:center;justify-content:space-between;margin-top:6px;color:var(--muted);font-size:12px}
  .delete{color:#ff7a7a;border-color:rgba(255,122,122,.4);background:linear-gradient(180deg,rgba(255,122,122,.12),rgba(0,0,0,.02))}

  /* Collapsible year/month styling (matches your day look) */
  details.year, details.month { padding:6px 0 }
  details.year > summary,
  details.month > summary {
    list-style:none; cursor:pointer;
    display:flex; align-items:center; justify-content:space-between; gap:8px;
  }
  details.year > summary::-webkit-details-marker,
  details.month > summary::-webkit-details-marker { display:none }

  /* Optional: subtle separators to help scan */
  details.year { border-top:1px solid var(--border) }
  .month-title { font-weight:700; opacity:.85; margin:2px 0 }
  .year-title  { font-weight:800; opacity:.9;  margin:2px 0 }


  /* --- Cloud status badge --- */
  .cloud-badge{
    font: 600 11px/1.1 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    letter-spacing:.3px;
    padding:6px 8px; border-radius:9px; border:1px solid var(--border);
    display:inline-grid; place-items:center; min-width:56px; user-select:none;
  }
  .cloud-badge.cloud-local{ color:#9aa0aa; background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,.03)); }
  .cloud-badge.cloud-ok{ color:#0bbd7e; border-color:rgba(11,189,126,.35); background:linear-gradient(180deg, rgba(11,189,126,.10), rgba(0,0,0,.03)); }
  .cloud-badge.cloud-error{ color:#ff7a7a; border-color:rgba(255,122,122,.40); background:linear-gradient(180deg, rgba(255,122,122,.12), rgba(0,0,0,.02)); }
  .cloud-badge.cloud-warn{ color:#f2b84b; border-color:rgba(242,184,75,.35); background:linear-gradient(180deg, rgba(242,184,75,.12), rgba(0,0,0,.02)); }
  .cloud-badge.cloud-syncing{
    color:#7aa2ff; border-color:rgba(122,162,255,.45); background:linear-gradient(180deg, rgba(122,162,255,.14), rgba(0,0,0,.03));
  }
  .cloud-badge.cloud-syncing::after{
    content:""; margin-left:6px; width:6px; height:6px; border-radius:50%;
    background: currentColor; display:inline-block; animation: cloudPulse .9s infinite ease-in-out;
  }
  @keyframes cloudPulse { 0%{opacity:.25; transform:scale(.8)} 50%{opacity:1; transform:scale(1)} 100%{opacity:.25; transform:scale(.8)} }

  /* ---- Minimal modal for link decision ---- */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:grid;place-items:center;z-index:1000}
  .modal .box{background:var(--card);color:var(--fg);border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);
    width:min(92vw,480px);padding:12px 12px}
  .modal h3{margin:0 0 6px 0;font-size:16px}
  .modal p{margin:0 0 10px 0;font-size:13px;color:var(--muted)}
  .modal .meta{font-size:12px;color:var(--muted);margin:8px 0}
  .modal .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}
  .modal .actions button{padding:8px 10px;border-radius:10px;border:1px solid var(--border);
    background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(0,0,0,.04));color:var(--fg);font-weight:600}
  .modal .actions .danger{color:#ff7a7a;border-color:rgba(255,122,122,.40);
    background:linear-gradient(180deg,rgba(255,122,122,.12),rgba(0,0,0,.02))}
  .modal .actions .primary{border-color:rgba(122,162,255,.45);
    background:linear-gradient(180deg,rgba(122,162,255,.14),rgba(0,0,0,.03))}

</style>

<div class="wrap">
  <div class="card">
    <div class="head">
      <div class="title" style="justify-content: space-between; flex:auto;">
        <div style="display:flex;align-items:center;gap:8px">
          <span class="emoji">⏰</span>
          <h1>timekeeper</h1>
        </div>

        <div style="display:flex;align-items:center;gap:8px">
          <span id="cloudBadge" class="cloud-badge cloud-local" title="Local-only">LOCAL</span>
          <button class="icon-btn" id="toggleSettings" title="Settings">⚙️</button>
          <button class="icon-btn" title="Show instructions" id="showHelp">?</button>
        </div>
      </div>
    </div>

    <div class="badge" id="instructions">
      <span class="muted">Install as an app (Add to Home Screen on iOS), then enable push:</span>
      <div class="spacer"></div>
      <button id="enable">Enable hourly notifications</button>
      <button class="icon-btn" id="dismiss" title="Hide tip">✕</button>
    </div>

    <div id="settings">
      <div class="muted" style="margin-bottom:6px">Cloud sync (npoint.io). If set, entries sync automatically; otherwise local-only.</div>
      <div class="settings-grid">
        <input id="npUrl" placeholder="npoint endpoint URL (e.g. https://api.npoint.io/abc123)"><br>
        <input id="npKey" placeholder="API key (Bearer)" type="password">
      </div>
      <div class="settings-actions">
        <button id="saveSettings">Save</button>
        <button id="syncNow">Sync now</button>
        <button id="clearSettings">Clear</button>
        <button id="exportBtn">Export (.csv)</button>
        <span id="syncStatus" class="muted"></span>
      </div>
    </div>

    <form id="entryForm">
      <textarea id="activityInput" placeholder="What are you doing right now? (one-liner is perfect)"></textarea>
      <div class="row" style="justify-content:space-between; margin-bottom: 16px;">
        <button type="submit" style="padding: 8px 16px">Save Entry</button>
        <span id="saved" class="muted hint"></span>
        <button id="toggleSort" class="icon-btn" title="Toggle sort">⇅</button>
      </div>
    </form>
    <div id="groups" class="groups"></div>
  </div>
</div>

<script>
// ==== CONFIG ====
const API_BASE = "https://tiny-push.timekeeper.workers.dev";
const VAPID_PUBLIC = "BBaXqZRplicwTZ4UK2RQBOEw4ZOIrj0lZ1eD8BGndehpfzVTcUgoC-Hpu3zXq6HQQOAkET6pGpYi0JqAfqoCWHk";
// ================

const STORAGE_KEY = 'activityEntries';
const UPDATED_AT_KEY = 'activityUpdatedAt';
const SHOW_HELP_KEY = 'showInstructions';
const NP_URL_KEY = 'np_url';
const NP_KEY_KEY = 'np_key';
const SORT_KEY = 'sortOrder'; // 'desc' (facebook) or 'asc' (biographic)

// Runtime-only collapse state (resets on full reload)
const uiState = {
  yearClosed: new Set(),             // keys: "2025"
  monthClosed: new Set(),             // keys: "2025-09"
  dayClosed:   new Set()              // keys: "YYYY-MM-DD"
};

const $ = sel => document.querySelector(sel);

const LINKED_KEY = 'cloud_linked'; // '1' once user chooses which side wins

function fmt(ts) {
  try { return new Date(ts).toLocaleString(); } catch { return ts || '—'; }
}

async function fetchRemotePreview(url, key) {
  const res = await fetch(url, { headers: { 'Authorization': `Bearer ${key}` } });
  if (!res.ok) throw new Error(`Cloud read failed (${res.status})`);
  const json = await res.json();
  return {
    entries: Array.isArray(json?.entries) ? json.entries : [],
    updatedAt: json?.meta?.updatedAt || null
  };
}

// 3-button modal. Returns 'cloud' | 'local' | 'cancel'
function showSyncChoice({ localCount, localStamp, remoteCount, remoteStamp }) {
  return new Promise(resolve => {
    const el = document.createElement('div');
    el.className = 'modal';
    el.innerHTML = `
      <div class="box">
        <h3>Choose source of truth</h3>
        <p>Linking cloud sync can overwrite data. Pick which side should win:</p>
        <div class="meta">
          <div>Local: <b>${localCount}</b> entries — updated <i>${fmt(localStamp) || 'n/a'}</i></div>
          <div>Cloud: <b>${remoteCount}</b> entries — updated <i>${fmt(remoteStamp) || 'n/a'}</i></div>
        </div>
        <div class="actions">
          <button data-k="cancel">Cancel</button>
          <button class="danger" data-k="cloud">Use Cloud</button>
          <button class="primary" data-k="local">Use Local</button>
        </div>
      </div>`;
    el.addEventListener('click', e => {
      const k = e.target?.dataset?.k;
      if (!k) return;
      el.remove();
      resolve(k);
    });
    document.body.appendChild(el);
  });
}



function setCloudBadge(state, tooltip){
  const el = $('#cloudBadge'); if(!el) return;
  el.className = `cloud-badge ${state}`;
  const label = {
    'cloud-local':'LOCAL',
    'cloud-syncing':'SYNCING…',
    'cloud-ok':'SYNCED',
    'cloud-warn':'STALE',
    'cloud-error':'ERROR'
  }[state] || '—';
  el.textContent = label;
  if (tooltip) el.title = tooltip;
}


function nowISO(){ return new Date().toISOString() }
function escapeHtml(s){return s.replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]))}
function getEntries(){ try{return JSON.parse(localStorage.getItem(STORAGE_KEY)||"[]")}catch{ return [] }}
// When bump=true, we mark a local write by updating UPDATED_AT_KEY to now.
function setEntries(arr, bump = false){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(arr));
  if (bump) localStorage.setItem(UPDATED_AT_KEY, nowISO());
}
function putEntry(text){
  const arr = getEntries();
  arr.unshift({ t: nowISO(), text });
  setEntries(arr, /* bump */ true);
}
function getCreds(){ return { url: localStorage.getItem(NP_URL_KEY)||'', key: localStorage.getItem(NP_KEY_KEY)||'' } }
function haveCreds(){ const {url,key}=getCreds(); return !!(url && key) }

function humanDay(d){
  return d.toLocaleDateString(undefined, { day:'numeric', weekday:'long' });
}
function humanMonth(d){ return d.toLocaleString(undefined,{month:'long'}) }

function sortPref(){ return localStorage.getItem(SORT_KEY) || 'desc' }
function setSortPref(v){ localStorage.setItem(SORT_KEY, v) }

function render(){
  const order = sortPref(); // 'asc' or 'desc'
  const arr = getEntries();
  const container = $('#groups');
  if (!arr.length) {
    container.innerHTML = `<div class="muted">No entries yet — your first one will appear here.</div>`;
    return;
  }

  // Group: Year -> Month(01..12) -> Day (DD)  [all LOCAL time]
  const groups = {};
  arr.forEach((e, index) => {
    const d = new Date(e.t);                           // e.t is ISO; Date handles TZ
    const y = String(d.getFullYear());
    const mIdx = String(d.getMonth()+1).padStart(2,'0'); // 01..12
    const mLabel = humanMonth(d);
    const dayKey = String(d.getDate()).padStart(2,'0');    // 01..31 (LOCAL)
    (groups[y] ||= {});
    (groups[y][mIdx] ||= { label: mLabel });
    (groups[y][mIdx][dayKey] ||= { label: humanDay(d), items: [] });
    groups[y][mIdx][dayKey].items.push({ ...e, index });
  });

  const cmp = order === 'asc' ? (a,b)=>a.localeCompare(b) : (a,b)=>b.localeCompare(a);

  let html = '';
  const years = Object.keys(groups).sort(cmp);
  for (const y of years) {
    const yOpen = !uiState.yearClosed.has(y);
    const monthKeys = Object.keys(groups[y]);
    const yearDayCount = monthKeys.reduce((acc, mk) => {
      const monthObj = groups[y][mk];
      const dayKeys = Object.keys(monthObj).filter(k => k !== 'label');
      return acc + dayKeys.length;
    }, 0);

    html += `<details class="year"${yOpen ? ' open' : ''} data-year="${y}">
      <summary><span class="year-title">${y}</span><span class="day-count">${yearDayCount} day${yearDayCount===1?'':'s'}</span></summary>`;

    const months = monthKeys.sort(cmp);
    for (const m of months) {
      const monthObj = groups[y][m];
      const mKey = `${y}-${m}`;
      const mOpen = !uiState.monthClosed.has(mKey);
      // day keys are direct children except 'label'
      const days = Object.keys(monthObj).filter(k => k !== 'label').sort(cmp);

      html += `<details class="month"${mOpen ? ' open' : ''} data-key="${mKey}">
        <summary><span class="month-title">${monthObj.label}</span><span class="day-count">${days.length} day${days.length===1?'':'s'}</span></summary>`;

      for (const day of days) {
        const { label, items } = monthObj[day];
        // Sort entries within the day by time per current order
        items.sort((a,b)=> order==='asc' ? new Date(a.t)-new Date(b.t) : new Date(b.t)-new Date(a.t));
        const dKey = day;                      // "DD" only
        const dOpen = !uiState.dayClosed.has(dKey);
        html += `<details class="day"${dOpen ? ' open' : ''} data-day="${dKey}">
          <summary><span>${label}</span><span class="day-count">${items.length} entr${items.length===1?'y':'ies'}</span></summary>
          <ul class="entries">`;
        for (const it of items) {
          const time = new Date(it.t).toLocaleTimeString(undefined,{hour:'2-digit',minute:'2-digit'});
          html += `<li>
            <details class="entry">
              <summary><div class="entry-text">${escapeHtml(it.text)}</div></summary>
              <div class="entry-meta">
                <span>${time}</span>
                <button class="delete" data-index="${it.index}" title="Delete">Delete</button>
              </div>
            </details>
          </li>`;
        }
        html += `</ul></details>`;
      }

      html += `</details>`; // /month
    }

    html += `</details>`; // /year
  }

  container.innerHTML = html;
  // Update toggle title
  const toggle = $('#toggleSort');
  toggle.title = order === 'asc' ? 'Sort: Old → New (click for New → Old)' : 'Sort: New → Old (click for Old → New)';
}

render();

// Save
document.getElementById('entryForm').addEventListener('submit', async e=>{
  e.preventDefault();
  const v = document.getElementById('activityInput').value.trim();
  if(!v) return;
  putEntry(v);
  document.getElementById('activityInput').value=''; render();
  document.getElementById('saved').textContent = 'Saved ✓'; setTimeout(()=>document.getElementById('saved').textContent='',1100);
  if (haveCreds()) {setCloudBadge('cloud-syncing','Syncing...'); await syncCloud('auto');}
});

// Delete (delegated)
document.addEventListener('click', async e=>{
  const btn = e.target.closest('.delete');
  if (!btn) return;
  const idx = parseInt(btn.dataset.index, 10);
  const arr = getEntries();
  if (Number.isInteger(idx) && idx >= 0 && idx < arr.length) {
    arr.splice(idx,1); setEntries(arr, true); render();
    if (haveCreds()) {setCloudBadge('cloud-syncing','Syncing...'); await syncCloud('auto');}
  }
});

// Remember open/closed for years & months while app runs (reset on reload)
document.addEventListener('toggle', (e) => {
  const el = e.target;
  if (!(el instanceof HTMLDetailsElement)) return;

  if (el.classList.contains('year')) {
    const y = el.dataset.year;
    if (!y) return;
    if (el.open) uiState.yearClosed.delete(y);
    else uiState.yearClosed.add(y);

  } else if (el.classList.contains('month')) {
    const k = el.dataset.key;
    if (!k) return;
    if (el.open) uiState.monthClosed.delete(k);
    else uiState.monthClosed.add(k);

  } else if (el.classList.contains('day')) {
    const d = el.dataset.day;            // "YYYY-MM-DD"
    if (!d) return;
    if (el.open) uiState.dayClosed.delete(d);
    else uiState.dayClosed.add(d);
  }
}, true);



// Sort toggle
document.getElementById('toggleSort').onclick = () => {
  const next = sortPref() === 'asc' ? 'desc' : 'asc';
  setSortPref(next);
  render();
};

// Instructions (auto-hide if already enabled)
const instructions = document.getElementById('instructions');
const showPref = localStorage.getItem(SHOW_HELP_KEY);
if (Notification.permission === 'granted' || showPref === 'false') instructions.style.display = 'none';

document.getElementById('dismiss').onclick = () => { instructions.style.display = 'none'; localStorage.setItem(SHOW_HELP_KEY,'false') };
document.getElementById('showHelp').onclick = () => { instructions.style.display = ''; localStorage.setItem(SHOW_HELP_KEY,'true') };

// Settings UI
const toggleSettingsBtn = document.getElementById('toggleSettings');
const settings = document.getElementById('settings');
const npUrlEl = document.getElementById('npUrl');
const npKeyEl = document.getElementById('npKey');
const syncStatus = document.getElementById('syncStatus');

toggleSettingsBtn.onclick = ()=>{ settings.style.display = (settings.style.display==='none'||!settings.style.display) ? 'block' : 'none' };

document.getElementById('saveSettings').onclick = async () => {
  const tempUrl = npUrlEl.value.trim();
  const tempKey = npKeyEl.value.trim();
  syncStatus.textContent = 'Checking…';

  // Don’t save creds yet. First, preview remote + compare to local.
  if (!tempUrl || !tempKey) {
    // Clearing creds
    localStorage.removeItem(NP_URL_KEY);
    localStorage.removeItem(NP_KEY_KEY);
    localStorage.removeItem(LINKED_KEY);
    setCloudBadge('cloud-local', 'Local-only');
    syncStatus.textContent = 'Cleared. Local-only mode.';
    return;
  }

  // Prepare local preview
  const localEntries = getEntries();
  const localStamp = localStorage.getItem(UPDATED_AT_KEY) || null;
  let remotePreview;
  try {
    setCloudBadge('cloud-syncing','Contacting cloud…');
    remotePreview = await fetchRemotePreview(tempUrl, tempKey);
  } catch (err) {
    setCloudBadge('cloud-error','Cloud read failed');
    syncStatus.textContent = 'Cloud read failed. Not linking.';
    return;
  }

  // If both sides have data and stamps may differ, ask the user.
  let choice = 'local'; // default if one side is empty
  const bothHaveSomething = (localEntries.length || localStamp) && (remotePreview.entries.length || remotePreview.updatedAt);
  if (bothHaveSomething) {
    choice = await showSyncChoice({
      localCount: localEntries.length,
      localStamp,
      remoteCount: remotePreview.entries.length,
      remoteStamp: remotePreview.updatedAt
    });
  } else if (!localEntries.length && !remotePreview.entries.length) {
    // nothing anywhere → just link but nothing to sync
    choice = 'local';
  } else if (!localEntries.length) {
    choice = 'cloud';
  } else {
    choice = 'local';
  }

  if (choice === 'cancel') {
    setCloudBadge('cloud-local','Local-only');
    syncStatus.textContent = 'Canceled. Not linked.';
    // IMPORTANT: do not store creds; leave inputs as typed.
    return;
  }

  // Persist creds + mark linked
  localStorage.setItem(NP_URL_KEY, tempUrl);
  localStorage.setItem(NP_KEY_KEY, tempKey);
  localStorage.setItem(LINKED_KEY, '1');

  // Enact chosen direction once, then enable auto sync
  if (choice === 'cloud') {
    // Pull: overwrite local from cloud, set UPDATED_AT to cloud stamp
    setEntries(remotePreview.entries, /* bump */ false);
    if (remotePreview.updatedAt) localStorage.setItem(UPDATED_AT_KEY, remotePreview.updatedAt);
    render();
    syncStatus.textContent = 'Linked. Used cloud → local.';
    setCloudBadge('cloud-ok','Pulled from cloud');
  } else {
    // Local wins: push once
    await syncCloud('push');
    syncStatus.textContent = 'Linked. Used local → cloud.';
  }

  startAutoSync();
};


document.getElementById('clearSettings').onclick = ()=>{
  localStorage.removeItem(NP_URL_KEY); localStorage.removeItem(NP_KEY_KEY);
  syncStatus.textContent = 'Cleared. Local-only mode.';
  setCloudBadge('cloud-local','Local-only');  
};
document.getElementById('syncNow').onclick = async ()=>{ 
  if (haveCreds()) {
    setCloudBadge('cloud-syncing','Syncing...'); 
    await syncCloud('auto');
  } 
};

// Load settings fields
(function initSettings(){
  const {url,key} = getCreds();
  npUrlEl.value = url; npKeyEl.value = key;
  setCloudBadge(haveCreds() ? 'cloud-syncing' : 'cloud-local', haveCreds() ? 'Checking cloud...' : 'Local-only');
})();

// Push enable (auto-hide instructions when done / already granted)
async function enablePush(){
  if(!('serviceWorker' in navigator)) return alert('Service Workers not supported here.');
  const reg = await navigator.serviceWorker.register('/sw.js', {scope:'/'});
  await navigator.serviceWorker.ready;

  if (Notification.permission === 'granted') {
    instructions.style.display = 'none';
    localStorage.setItem(SHOW_HELP_KEY, 'false');
    alert('Notifications already enabled. You can hide the instructions with ×.');
    return;
  }
  const perm = await Notification.requestPermission();
  if(perm !== 'granted') return alert('Permission denied.');

  const key = VAPID_PUBLIC.replace(/-/g,'+').replace(/_/g,'/');
  const appServerKey = Uint8Array.from(atob(key), c => c.charCodeAt(0));
  const sub = await reg.pushManager.subscribe({ userVisibleOnly:true, applicationServerKey: appServerKey });

  const r = await fetch(`${API_BASE}/subscribe`, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify(sub) });
  if(!r.ok) return alert('Subscribe failed.');

  instructions.style.display = 'none';
  localStorage.setItem(SHOW_HELP_KEY, 'false');
  alert('Hourly notifications enabled! (On iPhone: use the installed app)');
}
document.getElementById('enable').onclick = enablePush;

// Focus textarea if opened from notification
if (new URL(location).searchParams.get('ping') === '1') { document.getElementById('activityInput').focus() }

// ---------- Cloud sync (POST + Bearer), now safe on fresh devices ----------
async function syncCloud(mode = 'auto') {
  // modes:
  // 'auto'  -> compare stamps; push if local newer, pull if remote newer
  // 'pull'  -> unconditionally pull (if remote has data)
  // 'push'  -> unconditionally push

  // block auto until user explicitly links
  if (mode === 'auto' && localStorage.getItem(LINKED_KEY) !== '1') {
    setCloudBadge('cloud-warn', 'Cloud not linked yet');
    return;
  }  

  const { url, key } = getCreds();
  if (!url || !key) { setCloudBadge('cloud-local','Local-only'); return; }

  const newer = (a, b) => a && (!b || new Date(a) > new Date(b));
  const localEntries = getEntries();
  let localStamp = localStorage.getItem(UPDATED_AT_KEY) || null;
  // Bootstrap legacy installs that never had UPDATED_AT_KEY:
  if (!localStamp && localEntries.length) {
    localStamp = nowISO();
    localStorage.setItem(UPDATED_AT_KEY, localStamp);
  }

  setCloudBadge('cloud-syncing','Contacting cloud...');

  // GET remote (no push if GET fails)
  let remote;
  try {
    const res = await fetch(url, { headers: { 'Authorization': `Bearer ${key}` } });
    if (!res.ok) {
      $('#syncStatus') && ($('#syncStatus').textContent = 'Cloud read failed; not syncing.');
      setCloudBadge('cloud-error','Cloud read failed');
      return;
    }
    remote = await res.json();
  } catch (e) {
    console.warn('cloud GET error', e);
    $('#syncStatus') && ($('#syncStatus').textContent = 'Cloud read error; not syncing.');
    setCloudBadge('cloud-error','Cloud read error');
    return;
  }

  const remoteEntries = Array.isArray(remote?.entries) ? remote.entries : [];
  const remoteStamp = remote?.meta?.updatedAt || null;

  // Helpers
  async function doPull(reason='Pulled from cloud') {
    if (!remoteEntries.length && !remoteStamp) { $('#syncStatus') && ($('#syncStatus').textContent = 'Cloud empty; nothing to pull.'); setCloudBadge('cloud-ok','Up to date'); return; }
    // write entries without bump; then set UPDATED_AT to the cloud stamp
    setEntries(remoteEntries, /* bump */ false);
    if (remoteStamp) localStorage.setItem(UPDATED_AT_KEY, remoteStamp);
    render();
    $('#syncStatus') && ($('#syncStatus').textContent = reason);
    setCloudBadge('cloud-ok','Pulled');
  }

  async function doPush(reason='Synced to cloud') {
    try {
      // IMPORTANT: set meta.updatedAt to localStamp (latest entry), not "now"
      const stamp = localStamp || nowISO();
      const payload = { entries: localEntries, meta: { updatedAt: stamp } };
      const postRes = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
        body: JSON.stringify(payload)
      });
      if (!postRes.ok) throw new Error('POST failed');
      // Keep local UPDATED_AT in sync with what we wrote
      localStorage.setItem(UPDATED_AT_KEY, stamp);
      $('#syncStatus') && ($('#syncStatus').textContent = reason);
      setCloudBadge('cloud-ok','Synced');
    } catch (e) {
      console.warn('cloud POST error', e);
      $('#syncStatus') && ($('#syncStatus').textContent = 'Cloud write error.');
      setCloudBadge('cloud-error','Cloud write error — local only');
    }
  }

  // Mode behavior
  if (mode === 'pull') {
    return await doPull('Pulled (manual)');
  }
  if (mode === 'push') {
    // If local is empty, don’t upload emptiness; just pull
    if (!localEntries.length && remoteEntries.length) return await doPull('Pulled (local empty)');
    return await doPush('Synced (manual)');
  }

  // AUTO: decide by stamps (or by emptiness)
  if (!localStamp && !remoteStamp) { $('#syncStatus') && ($('#syncStatus').textContent = 'Nothing to sync.'); setCloudBadge('cloud-ok','Up to date'); return; }
  if (!localStamp && remoteStamp) { return await doPull('Pulled (no local stamp)'); }
  if (localStamp && !remoteStamp) { return await doPush('Synced (no cloud stamp)'); }

  if (newer(localStamp, remoteStamp)) {
    return await doPush('Synced (local newer)');
  } else if (newer(remoteStamp, localStamp)) {
    return await doPull('Pulled (cloud newer)');
  } else {
    // equal stamps → assume in sync
    $('#syncStatus') && ($('#syncStatus').textContent = 'Already in sync.');
    setCloudBadge('cloud-ok','Up to date');
    return;
  }
}

let syncTimer = null;
function startAutoSync(){
  if (syncTimer) clearInterval(syncTimer);
  if (!haveCreds() || localStorage.getItem(LINKED_KEY) !== '1') return;
  setTimeout(() => syncCloud('auto'), 1500);
  syncTimer = setInterval(() => { if (!document.hidden) syncCloud('auto'); }, 60_000);
  window.addEventListener('focus', () => syncCloud('auto'));
}


function entriesToCSV(rows) {
  // Header
  const out = ['timestamp,text'];
  for (const r of rows) {
    const ts = r.t || '';
    // Escape CSV content: wrap in quotes, double any inner quotes, normalize newlines
    const text = String(r.text ?? '')
      .replace(/"/g, '""')
      .replace(/\r?\n|\r/g, ' / ');
    out.push(`"${ts}","${text}"`);
  }
  return out.join('\r\n');
}

async function exportCSV() {
  const entries = getEntries();
  if (!entries.length) { alert('No entries to export.'); return; }

  // Sort chronologically (old→new) for export readability
  const sorted = [...entries].sort((a,b)=> new Date(a.t) - new Date(b.t));

  const csv = entriesToCSV(sorted);
  const blob = new Blob(["\uFEFF" + csv], { type: 'text/csv;charset=utf-8' }); // BOM for Excel
  const now = new Date();
  const pad = n => String(n).padStart(2,'0');
  const filename = `timekeeper-${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}.csv`;

  // Prefer Share sheet if supported (mobile)
  try {
    if (navigator.canShare && 'share' in navigator && typeof File !== 'undefined') {
      const file = new File([blob], filename, { type: 'text/csv' });
      if (navigator.canShare({ files: [file] })) {
        await navigator.share({ files: [file], title: 'timekeeper export' });
        return;
      }
    }
  } catch (err) {
    // If user cancels share, fall through to download
    console.warn('share failed or cancelled', err);
  }

  // Fallback: trigger download
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
}

// Wire up button
document.getElementById('exportBtn').onclick = exportCSV;



// On load: safe, non-destructive bootstrap
// On load: pull-only so we never upload on first run
(async function initialSync(){
  if (haveCreds() && localStorage.getItem(LINKED_KEY) === '1') {
    setCloudBadge('cloud-syncing','Checking cloud…');
    await syncCloud('auto');
    startAutoSync();
  } else {
    setCloudBadge('cloud-local','Local-only');
  }
})();



</script>
